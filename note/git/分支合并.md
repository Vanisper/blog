# 分支合并

将开发分支合并到主分支的步骤如下，具体操作取决于是否使用远程仓库（如GitHub）的Pull Request流程或直接在本地合并：

---

### 本地直接合并（适合个人项目）

1. **提交开发分支的更改**

确保所有更改已提交并推送到远程开发分支：
``` bash
git checkout develop
git add .
git commit -m "完成开发工作"
git push origin develop
```

2. **切换到主分支并更新**

拉取远程主分支的最新代码：
``` bash
git checkout main
git pull origin main
```

3. **合并开发分支到主分支**

使用 `--no-ff` 保留合并记录（即使可**快进**）：
> git 存在一个配置 `merge.ff`，如果没有设置过的话，默认是“快进合并”，故 merge 时通常需要手动指定 `--no-ff` 参数
>
> 如果需要修改全局 git 配置，强制 **非快进模式** 合并的话，可以手动设置 `git config --global merge.ff false`。
``` bash
git merge --no-ff develop
```

> “**快进合并**” 是 Git 合并操作中的一个关键概念，此处 “即使可快进” 的含义是：即使当前分支的合并可以通过“快进”（fast-forward）直接完成，也要强制生成一个明确的合并提交记录。文末将通过一个通俗的例子和对比来解释。

4. **解决合并冲突（如有）**

  - 手动编辑冲突文件（查找 <<<<<<< 标记）。
  - 确认更改后标记为已解决：
    ``` bash
    git add <冲突文件>
    git commit -m "解决合并冲突"
    ```

5. **推送主分支到远程**

``` bash
git push origin main
```

---

### 通过Pull Request合并（推荐团队使用）

1. **推送开发分支到远程**

``` bash
git push origin develop
```

2. **在GitHub/GitLab创建PR/MR**

    - 进入仓库页面，选择 `New Pull Request`。
    - 设置 `base` 为主分支（如 `main`），`compare` 为开发分支（如 `develop`）。

3. **代码审查与自动化检查**

    - 团队成员审查代码。
    - 确保CI/CD测试通过。

4. **合并PR**

    - 选择合并方式：
      - **`Create a merge commit`**：保留完整历史。
      - **`Squash and merge`**：压缩为单个提交。
      - **`Rebase and merge`**：线性历史（无合并提交）。

5. **删除远程开发分支（可选）**

合并后可在界面勾选删除远程分支。

---

### 注意事项

- **分支保护**：若主分支受保护，需通过PR合并，禁止直接推送。

- **同步更新**：合并前建议将主分支最新代码同步到开发分支：
  ``` bash
  git checkout develop
  git merge main   # 或使用 git rebase main
  ```

- **回滚合并**：若合并后发现问题，使用 `git revert` 撤销：
  ``` bash
  git revert -m 1 <合并提交的哈希值>
  ```

---

根据项目规范选择合适的方式，团队协作推荐使用Pull Request确保代码审查与质量。

---

## 快进合并

### 1. 什么是“快进合并”（fast-forward）？

假设你的主分支（`main`）和开发分支（`develop`）的提交历史如下：
```
main:   A → B → C
develop:          → D → E
```

- `main` 分支停留在提交 `C`，而 `develop` 分支在 `C` 的基础上新增了提交 `D` 和 `E`。
- **如果此时将 `develop` 合并到 `main`**：
  - 因为 `main` 分支没有新的提交（即 `develop` 的提交直接领先于 `main`），Git 默认会执行“快进合并”：
    - 直接将 `main` 的指针移动到 `develop` 的最新提交 `E`。
    - **结果历史看起来像一条直线**：
      ```
      main/develop: A → B → C → D → E
      ```
    - 合并后的历史中**没有合并提交**，无法看出分支的存在。

### 2. `--no-ff` 的作用

使用 `--no-ff`（`--no-fast-forward`）时，Git **即使可以快进**，也会强制生成一个新的合并提交，保留分支的合并痕迹：
``` bash
git checkout main
git merge --no-ff develop
```

- **合并后的历史会明确显示分支的存在：**
  ```
  main:   A → B → C → F (合并提交)
  develop:          → D → E ↗
  ```
  - `F` 是一个新的合并提交，记录了“将 `develop` 合并到 `main`”的操作。
  - 即使 `main` 没有新提交，历史中也会保留分支的合并轨迹

### 3. 为什么要“即使可快进”也要保留合并记录？

- **清晰的历史追踪**：
  - 快进合并会让分支历史“消失”，无法看出某个功能是何时、如何合并到主分支的。
  - `--no-ff` 会明确标记合并点，方便后续查看分支的生命周期（比如功能开发、Bug 修复等）。

- **团队协作的规范**：
  - 在团队项目中，主分支（如 `main`）通常受保护，合并必须通过 Pull Request（PR）审查。
  - 强制生成合并提交可以关联 PR 的讨论记录，方便追溯代码变更的上下文。

- **回滚的便利性**：
  - 如果合并后发现问题，可以通过回滚合并提交（`git revert F`）直接撤销整个分支的变更，而不必逐个提交处理。

### 4. 对比示例

- **默认的快进合并（无 `--no-ff`）**：
  ```
  main:   A → B → C → D → E
  ```
  - 看不出 `D` 和 `E` 是来自 `develop` 分支的提交。

- **使用 --no-ff 的合并**：
  ```
  main:   A → B → C → F (合并提交)
                        ↘
  develop:          → D → E ↗
  ```
  - 合并提交 `F` 明确记录了“将 `develop` 合并到 `main`”的操作。

### 总结

- **“即使可快进”** 的含义是：**即使可以直接移动分支指针（快进），也要强制生成一个合并提交**。
- **适用场景**：团队协作、需要保留分支历史的项目。
- **相反选项**：**`--ff`**（默认行为，允许快进时不生成合并提交）。
